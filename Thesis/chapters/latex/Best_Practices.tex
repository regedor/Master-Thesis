\thispagestyle{empty}
\chapter{Best Practices}\label{chap:best_practices}

Best practices are not rules, they are standards followed by a specific community.
Something that most people agrees with, although it might not be scientifically proven,
it seems to be the best way of handling a problem.

In this chapter we will understand how important best practices are for open source communities, 
how they give meaning to traditional software metrics
and identify some examples of best practices from the ruby community.


\section{Best Practices in Open Source Software Projects} \label{sec:best_practices_ossp}
Open source communities have a tendency to create \emph{coding rules},
i.e., \emph{principles governing the conduct of programmers and serving as a basis of measure or judgment}. 
It is a natural and evolutive process for people surviving in an open space.
We can call these natural rules: \emph{best practices}.

Best practices are  methods thought as being the  best way for achieving something;
they are spread through the community and everybody does it that way.
It is obvious that when a developer follows well established principles and best practices, 
the project maintainability is increased.
Consequently, project new comers will find it easier to understand the project code~\cite{dromey2002model}.
But there is more than that, following best practices discourage:
\begin{itemize}
\item Poor performance (due to bad patterns)
\item Poor error checking (defensive programming)
\item Inconsistent exception handling / Maintainability (long-term quality)
\end{itemize}

To attain the same benefits, companies define standards, this is, something considered by an authority 
as a basis of comparison and a normal requirement for quality;
by other words, an approved behavior model for their workers.
However, these principles are defined by the few people on top and then spread down on the pyramid.
Many times, those rules are not well thought by the project leaders and that can block the progress.

In the other way around, the apparent chaos of open source also requires some rules,
but contrary to the companies coding standards, which work in a top down way,
best practices happen in a bottom up and distributive mode,
everybody can try different ways of doing things,
but the ones with better results are most likely to be copied.

A simple metaphor exposes the difference:
\begin{quote}\emph{
  Companies use traffic lights where open source communities use roundabouts.
}\end{quote}

Both, the strict company standards (traffic lights) and the OSP best practices (roundabouts) are ways to regulate intersections.
The result of traffic lights is  easier to predict, however that regulation  system does not depend much on the drivers skills;
because it is so restrictive it will happen often to find a driver stooped alone
at the crossroads waiting for a green light, losing precious time.
On the other hand, the roundabout system is a less restricted system and relies much more on the quality of the drivers,
but it open the possibility to a much more efficient way to avoid a traffic jam.

There is little work done concerned with measuring coding best practices by automatic analyzing source code.
A plausible explanation for that is the fact that best practices are not a set of immutable rules,
they are a continuous evolution and improvement of development methodologies.
Communities are constantly creating rules and best practices, even without noticing it.
It is not possible to write down a list of best practices without some ambiguities.

At first glance, best practices metrics seam to be for classic metrics as natural as medicine is for science.
But, it is not the case.
In fact, classic metrics, on their own, do not give much information about a project.
In many cases, best practices can be the key to understand what should be the optimum value for a classic metric,
for instance, to determine \emph{how many lines of code should a ruby method have}.

Of course, those questions are subjective.
However, by analyzing renowned projects, developers opinions and so on, it is possible to find out a best practice
that gives a plausible answer to the search for the \emph{most favorable value}.

In addition, it is possible to use known source code metrics and, by analyzing their values, 
to find new correlations that might give hints about weather some methodological approaches were 
taken into account during the project development process.

We believe that best practices can give a meaning to metrics.

\section{Identifying Best Practices} \label{sec:identifying_best_practices}
We understood that software projects can benefit a lot from using best practices.
However, what is a best practice after all?
The truth is that everything can be a best practice, for example:
the use of two spaces to indent code and no tabs; 
writing unit tests for your code;
the way files are organized inside a project; etc.

Some of those things might look like a matter of taste,
but the truth is that every worthy ruby developer uses two spaces to indent code.
This is the standard for the ruby community. 
Other communities, for instance JavaScript programers, prefer 4 spaces
and in the Java world 8 spaces is considered the considered a good choice.

It is important to notice,
that we can find virtually no ruby programmer using a different indentation, 
but we can find Java communities advocating different indentations.
This fact shows that the ruby community agrees that 2 spaces is a the best option and
can be considered a best practice.
In contrast, we can not be completely sure about the 8 spaces for Java,
since there is also a lot of developers advocating 4 spaces and also a good number using tabs instead.
The Java community is divide, it almost possible to identify sub communities defending 
different answers for the same questions. 
It might be possible to identify conventions in those smaller communities, 
but it will be harder to do it for the bigger community.

To consider this conventions as a best practice, it is important to understand if that
conventions are strong through the community in question. 
Because of that, it is obvious that the first step before finding best practices is to identify the community:
are we trying to find best practices for ruby programers general? for all programers in general? 
for the programers working in a specific company or project?

In smaller communities, it might be easier to achieve agreement and
consequently find best practices.
However, best practices created and followed by a small groups,
are less likely to be considered strong best practices compared to 
best practices followed by the developers working on the top 10 open source projects.

It is clear that best practices are specific to a certain community, 
so, after correctly choosing a community, to find identify best practices we need
to find out what patterns are used by its members, 
and to prove that they are real best practices that should be followed, 
it is important to prove that some benefit comes from using it.

The most obvious benefit from using it,
is that the project maintainability is increased,
for example: people in the community might be expecting to find the code indented with two spaces or 
methods named in camelcase, constants in upcase, etc.

Supposedly using two or more spaces does not affect directly the code quality (other than maintainability), 
but it is reasonable to infer that a developer is new to ruby if he does not know it.
In other words, following, or not, best practices has a relation with the developer knowledge and experience,
and the developer experience is likely to be related with the code quality produced.

Of course, best practices are not only related to naming,
they can also be patterns for solving certain problems, working methodologies, etc.
In those cases, they might be directly related to other quality attributes like performance and so on.

In the end, it seems plausible to believe that there is a correlation between this two variables.
The quantity of best practices followed and the overall quality of the project. 

Later in this document, this relation between these variables relation is proved.


\section{Best Practices Examples} \label{sec:best_practices_examples}
In this section, different best practices categories are listed.

These are best practices for the ruby community.

Best practices related to code formatting:
\begin{itemize}
\item \emph{Use two spaces to indent code and no tabs}, every worthy ruby developer do it that way.
\item \emph{Remove trailing whitespace}, trailing whitespace makes noises in version control systems.
\end{itemize}

Related to syntax:
\begin{itemize}
\item \emph{Avoid return where not required}.
\item \emph{Suppress superfluous parentheses}, when calling methods, 
but keep them when calling \"functions\" (when you use the return value in the same line).
\end{itemize}

Related to naming:
\begin{itemize}
\item \emph{Use snake\_case for methods}.
\item \emph{Other method naming conventions}: Use map over collect, find over detect, find\_all over select, size over length.
\end{itemize}

Specific to a framework (Ruby on Rails in for the following examples):
\begin{itemize}
\item \emph{Law of Demeter}, A model should only talk to its immediate association.
\item \emph{Move code into controller}, according to MVC architecture, there should not be logic codes in view.
\item \emph{Isolate seed data}, do not insert seed data during migrations, a 
rake task\footnote{ 
  Rakefiles work in similar way to Makefiles but are written in ruby. It is a simple way to write code to automate repetitive tasks. 
} can be used instead.
\item \emph{Do not use default route}, When using a RESTful design. The default RoR routes can cause a security problems.
\item \emph{Replace Complex Creation with Factory Method}, Sometimes you will build a complex model with params, current\_user and other logics in controller, but it makes your controller too big, you should move them into model with a factory method.
\end{itemize}




\section{Ruby on Rails Best Practices} \label{sec:ror_best_practives}

Ruby and Ruby on Rails community members are, in general, known has been addicted to best practices.
In reality, many of those best practices are studied development methodologies.
It is common to associate Ruby on Rails with Behaviour Driven Development (BDD) and Agile methodologies.
And, most ruby developers, even language new comers, are worried about following Rails philosophies and best practices.
The majority of Ruby on Rails book authors speak about convention over configuration,
those conventions can be be seen as best practices too.

Because of all this, the Rails community has great potential to be a starting point to understand the role of best practices, 
what benefits come from using it and how to measure best practices.

The first step is to define the community: Rails developers. 
After that, we need to find procedures or methodologies that most of people, in the community, agrees to consider it as best practice.
The simplest way is to ask people in the community. 
In fact, there was already some work done here.
The web site
\textsf{Rails Best Practices}\footnote{\url{http://www.rails-bestpractices.com/} is a web site created by Richard Huang,
it was inspired by Wen-Tien Chang talk given at Kungfu RailsConf 2009 in Shanghai. Slides can be found here
\url{http://www.slideshare.net/ihower/rails-best-practices}.},
works in similar way to a web forum and its objective is to engage developers to discuss which practices
should be considered best practices to follow, when building a Rails web application.
At Rails Best Practices Web Site, every Rails developer can suggest new best practices,
improve and comment suggested best practices and vote whether he considers it a best practice or not.

After deciding that some \emph{procedure} is a \emph{best practice},
it would be handy to find a way to automatically verify whether 
that practice is being followed by the developers of a given project.
With that in mind, an open source ruby 
\textsf{gem}\footnote{
  Ruby Libraries are called gems. Ruby gems can be easily managed using rubygems 
  (rubygems is for Ruby as aptitude is for Debian or cpan for perl).
}, 
called rails\_best\_practices, was created (by the authors of Rails best practices web site) 
based on the most voted best practices. 
After installing the gem, it is possible to run it against any Rails project.
and it will automatically produce a report that shows where,
in the source code, a project is failing to obey to consensual best practices.
It is important to notice that the rails\_best\_practices gem does not say if a project is following best practices,
it does the opposite, shows where the project is failing.

At the moment of writing, this gem can check for 33 different best practices from more then 70 described in the web site.
We did a few commits to this gem source code, to improve and correct some bugs, 
everybody is welcome to do it and to help with the writing of more best practices failing detectors.

\subsection{Best Practices Considered}\label{subsec:second_study}



\subsubsection{Remove Tab}
  Make sure there are no tabs in files.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/81-remove-tab}
   
\subsubsection{Remove Trailing Whitespace }  
  Make sure there are no trailing whitespace in codes.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/60-remove-trailing-whitespace}
   
\subsubsection{Add Model Virtual Attribute}
  Make sure to add a model virual attribute to simplify model creation.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/4-add-model-virtual-attribute}
       
\subsubsection{Always Add Db Index}
  Review db/schema.rb file to make sure every reference key has a database index.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/21-always-add-db-index}
       
\subsubsection{Dry Bundler In Capistrano}
  Review config/deploy.rb file to make sure using the bundler's capistrano recipe.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/51-dry-bundler-in-capistrano}
   
\subsubsection{Isolate Seed Data }
  Make sure not to insert data in migration, move them to seed file.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/20-isolating-seed-data.}
   
\subsubsection{Keep Finders On Their Own Model}
  Review model files to ake sure finders are on their own model.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/13-keep-finders-on-their-own-model.}
   
\subsubsection{Law Of Demeter }
  Review to make sure not to avoid the law of demeter.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/15-the-law-of-demeter.}
   
\subsubsection{Move Code Into Controller}
  Review a view file to make sure there is no finder, finder should be moved to controller.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/24-move-code-into-controller.}
   
\subsubsection{Move Code Into Helper }
  Review a view file to make sure there is no complex options\_for\_select message call.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/26-move-code-into-helper.}
   
\subsubsection{Move Code Into Model }
  Review a view file to make sure there is no complex logic call for model.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/25-move-code-into-model.}
     
\subsubsection{Move Finder To Named Scope }
  Review a controller file to make sure there are no complex finder.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/1-move-finder-to-named_scope.}
   
\subsubsection{Move Model Logic Into Model}
  Review a controller file to make sure that complex model logic should not exist in controller, should be moved into a model.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/7-move-model-logic-into-the-model.}
   
\subsubsection{Needless Deep Nesting}
  Review config/routes.rb file to make sure not to use too deep nesting routes.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/11-needless-deep-nesting.}
   
\subsubsection{Not Use Default Route}
  Review config/routes file to make sure not use default route that rails generated.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/12-not-use-default-route-if-you-use-restful-design}
   
\subsubsection{Not Use Time Ago In Words}
  Review view and helper files to make sure not use time\_ago\_in\_words or distance\_of\_time\_in\_words\_to\_now.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/105-not-use-time_ago_in_words.}
   
\subsubsection{Overuse Route Customizations}
  Review config/routes.rb file to make sure there are no overuse route customizations.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/10-overuse-route-customizations.}
   
\subsubsection{Protect Mass Assignment}
  Review model files to make sure to use attr\_accessible or attr\_protected to protect mass assignment.
 
  See the best practices details here \url{http://rails-bestpractices.com/posts/148-protect-mass-assignment.}
   
\subsubsection{Remove Empty Helpers Review}
  Review a helper file to make sure it is not an empty moduel.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/72-remove-empty-helpers.}
   
\subsubsection{Remove Unused Methods In Controllers}
  Find out unused methods in controllers.
   
\subsubsection{Remove Unused Methods In Helpers}
  Find out unused methods in helpers.
       
\subsubsection{Remove Unused Methods In Models}
  Find out unused methods in models.
   
\subsubsection{Replace Complex Creation With Factory Method}
  Review a controller file to make sure that complex model creation should not exist in controller, should be replaced with factory method.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/6-replace-complex-creation-with-factory-method.}
   
\subsubsection{Replace Instance Variable With Local Variable}
  Review a partail view file to make sure there is no instance variable.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/27-replace-instance-variable-with-local-variable.}
   
\subsubsection{Restrict Auto Generated Routes}
  Review a route file to make sure all auto-generated routes have corresponding actions in controller.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/86-restrict-auto-generated-routes}
   
\subsubsection{Simplify Render In Controllers}
  Review a controller file to make sure using simplified syntax for render.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/62-simplify-render-in-controllers.}
   
\subsubsection{Simplify Render In Views}
  Review a view file to make sure using simplified syntax for render.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/61-simplify-render-in-views.}
   
\subsubsection{Use Before Filter}
  Review a controller file to make sure to use before\_filter to remove duplicated first code line in different action.
 
  % See the best practice detailed here \url{http://rails-bestpractices.com/posts/22-use-before_filter.}
   
\subsubsection{Use Model Association}
  review a controller file to make sure to use model association instead of foreign key id assignment.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/2-use-model-association.}
   
\subsubsection{Use Multipart Alternative As Content Type Of Email}
  Make sure to use multipart/alternative as content\_type of email.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/41-use-multipart-alternative-as-content\_type-of-email.}
   
\subsubsection{Use Observer}
  Make sure to use observer (sorry we only check the mailer deliver now).
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/19-use-observer.}
   
\subsubsection{Use Query Attribute}
  Make sure to use query attribute instead of nil?, blank? and present?.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/56-use-query-attribute.}
   
\subsubsection{Use Say With Time In Migrations}
  Review a migration file to make sure to use say or say\_with\_time for customized data changes to produce a more readable output.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/46-use-say-and-say\_with\_time-in-migrations-to-make-a-useful-migration-log.}
   
\subsubsection{Use Scope Access}
  Review a controller to make sure to use scope access instead of manually checking current\_user and redirect.
 
  % See the best practice details here \url{http://rails-bestpractices.com/posts/3-use-scope-access.}


